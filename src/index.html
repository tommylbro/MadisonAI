import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, collection, onSnapshot, addDoc, serverTimestamp, query, orderBy } from 'firebase/firestore';
import { marked } from 'marked'; // Import the 'marked' library for markdown parsing

// Icon components for the UI
const WandIcon = ({ size = 24 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-sparkles">
        <path d="M12 2c.4 0 .8.2 1.04.62l1.9 3.9a.75.75 0 0 0 .6.3c.26 0 .5-.1.6-.3L18 4l2.9-2.3a.75.75 0 0 1 .6.3l.2.4c.1.2 0 .4-.2.6L18 8l3.9 1.9c.4.2.4.6 0 .8L18 12l.2 3.6c.1.2 0 .4-.2.6L14 20l-1.9 3.9a.75.75 0 0 1-.6.3c-.26 0-.5-.1-.6-.3L9 20l-1.9-3.9a.75.75 0 0 1-.6-.3c-.26 0-.5.1-.6.3L2 12l.2-3.6c.1-.2 0-.4-.2-.6L6 4l2.9-2.3a.75.75 0 0 1 .6-.3L12 2z" />
        <path d="M12 12l1.9 3.9a.75.75 0 0 0 .6.3c.26 0 .5-.1.6-.3L17 12l-1.9-3.9a.75.75 0 0 0-.6-.3c-.26 0-.5.1-.6.3L12 12z" />
    </svg>
);

const CodeIcon = ({ size = 24 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-code">
        <polyline points="16 18 22 12 16 6" />
        <polyline points="8 6 2 12 8 18" />
    </svg>
);

const MusicIcon = ({ size = 24 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-music-4">
        <path d="M9 18V5l12-2v13" />
        <circle cx="6" cy="18" r="3" />
        <circle cx="18" cy="16" r="3" />
    </svg>
);

const AudioWaveformIcon = ({ size = 24 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-waveform">
        <path d="M2 12h2a2 2 0 0 1 2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 1 2-2h2" />
    </svg>
);

const MicIcon = ({ size = 24 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-mic">
        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z" />
        <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
        <line x1="12" x2="12" y1="19" y2="22" />
    </svg>
);

const SendIcon = ({ size = 24 }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-send">
        <path d="M22 2L11 13" />
        <path d="M22 2L15 22L11 13L2 9L22 2Z" />
    </svg>
);

const App = () => {
    // State variables for managing app functionality
    const [messages, setMessages] = useState([]);
    const [input, setInput] = useState('');
    const [activeMode, setActiveMode] = useState('refine');
    const [isAIGenerating, setIsAIGenerating] = useState(false);
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [firestoreError, setFirestoreError] = useState(null);
    const [isTunerActive, setIsTunerActive] = useState(false);
    const [tunerStatus, setTunerStatus] = useState('No sound detected');
    // State to track if a microphone device is available
    const [microphoneAvailable, setMicrophoneAvailable] = useState(true);

    // Audio-related state and refs for the instrument tuner
    const audioContextRef = useRef(null);
    const analyserRef = useRef(null);
    const sourceRef = useRef(null);
    const pitchDetectorWorkerRef = useRef(null);
    const animationFrameIdRef = useRef(null);

    // Firebase state and config
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const messagesEndRef = useRef(null);

    // Helper function to scroll to the bottom of the chat
    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    // Initialize Firebase and set up authentication
    useEffect(() => {
        const initFirebase = async () => {
            try {
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

                if (!firebaseConfig || !firebaseConfig.apiKey) {
                    console.error("Firebase config is missing or invalid.");
                    setFirestoreError("Error: Firebase configuration is missing. Please ensure the app is configured correctly.");
                    return;
                }

                const app = initializeApp(firebaseConfig);
                const firestore = getFirestore(app);
                const firebaseAuth = getAuth(app);

                setDb(firestore);
                setAuth(firebaseAuth);

                onAuthStateChanged(firebaseAuth, async (user) => {
                    if (user) {
                        setUserId(user.uid);
                        setIsAuthReady(true);
                        setFirestoreError(null);
                    } else {
                        const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (token) {
                            try {
                                await signInWithCustomToken(firebaseAuth, token);
                            } catch (e) {
                                console.error("Error signing in with custom token:", e);
                                setFirestoreError("Error connecting to Firestore: Custom authentication failed.");
                            }
                        } else {
                            try {
                                await signInAnonymously(firebaseAuth);
                            } catch (e) {
                                console.error("Error signing in anonymously:", e);
                                setFirestoreError("Error connecting to Firestore: Anonymous authentication failed.");
                            }
                        }
                    }
                });
            } catch (e) {
                console.error("Failed to initialize Firebase:", e);
                setFirestoreError("Error initializing Firebase. Please check the configuration.");
            }
        };

        initFirebase();
    }, []);

    // Check for microphone device availability on component mount
    useEffect(() => {
        const checkMicrophone = async () => {
            if (!navigator.mediaDevices) {
                setMicrophoneAvailable(false);
                return;
            }
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const hasMicrophone = devices.some(device => device.kind === 'audioinput');
                setMicrophoneAvailable(hasMicrophone);
            } catch (err) {
                console.error("Error enumerating devices:", err);
                setMicrophoneAvailable(false);
            }
        };
        checkMicrophone();
    }, []);

    // Set up Firestore data listener
    useEffect(() => {
        if (db && userId && isAuthReady) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const userChatsCollection = collection(db, `artifacts/${appId}/users/${userId}/chats`);
            
            const q = query(userChatsCollection, orderBy('timestamp', 'asc'));

            const unsubscribe = onSnapshot(q, (snapshot) => {
                const fetchedMessages = [];
                snapshot.forEach(doc => {
                    fetchedMessages.push(doc.data());
                });
                setMessages(fetchedMessages);
            }, (error) => {
                console.error("Error fetching messages from Firestore:", error);
                setFirestoreError("Error fetching chats. Please check your network connection and try again.");
            });

            return () => unsubscribe();
        }
    }, [db, userId, isAuthReady]);

    // Handle initial scroll and new message scrolls
    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    // Function to handle sending a new message
    const handleSendMessage = async (prompt, type) => {
        if (!prompt.trim() || !isAuthReady) return;

        const newUserMessage = {
            role: 'user',
            text: prompt,
            timestamp: serverTimestamp(),
            type: type,
        };

        try {
            await addDoc(collection(db, `artifacts/${appId}/users/${userId}/chats`), newUserMessage);
        } catch (e) {
            console.error("Error adding user message to Firestore:", e);
            setFirestoreError("Could not save your message. Please try again.");
        }

        setInput('');
        setIsAIGenerating(true);
        
        const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
        
        try {
            const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.statusText}`);
                    }
                    return response;
                } catch (error) {
                    if (retries > 0) {
                        await new Promise(res => setTimeout(res, delay));
                        return fetchWithRetry(url, options, retries - 1, delay * 2);
                    } else {
                        throw error;
                    }
                }
            };
            
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: chatHistory,
            };

            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            
            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const generatedText = result.candidates[0].content.parts[0].text;

                const newAIMessage = {
                    role: 'assistant',
                    text: generatedText,
                    timestamp: serverTimestamp(),
                    type: type,
                };
                
                try {
                    await addDoc(collection(db, `artifacts/${appId}/users/${userId}/chats`), newAIMessage);
                } catch (e) {
                    console.error("Error adding AI message:", e);
                    setFirestoreError("Could not save AI response. Please try again.");
                }
            } else {
                console.error("Unexpected API response format:", result);
                setFirestoreError("AI response failed. Please try again.");
            }

        } catch (e) {
            console.error("API call error:", e);
            setFirestoreError("Failed to get a response from the AI. Check your network or try again later.");
        } finally {
            setIsAIGenerating(false);
        }
    };

    const handleRefineWriting = () => {
        handleSendMessage(input, 'refine');
    };

    const handleExplainCode = () => {
        handleSendMessage(input, 'explain');
    };

    // Markdown rendering with marked.js
    const renderMarkdown = (markdownText) => {
        return marked.parse(markdownText);
    };

    // Instrument Tuner Logic
    const startTuner = async () => {
        if (isTunerActive || !microphoneAvailable) return;

        setIsTunerActive(true);
        setTunerStatus('Listening...');

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            analyserRef.current = audioContextRef.current.createAnalyser();
            analyserRef.current.fftSize = 2048;
            sourceRef.current = audioContextRef.current.createMediaStreamSource(stream);
            sourceRef.current.connect(analyserRef.current);

            pitchDetectorWorkerRef.current = new Worker(URL.createObjectURL(new Blob([
                `function autoCorrelate(buffer, sampleRate) {
                    let SIZE = buffer.length;
                    let bestOffset = -1;
                    let bestCorrelation = 0;
                    let rms = 0;
                    
                    for (let i = 0; i < SIZE; i++) {
                        let val = buffer[i];
                        rms += val * val;
                    }
                    rms = Math.sqrt(rms / SIZE);
                    if (rms < 0.01) { 
                        return -1;
                    }
                    
                    let correlation = new Array(SIZE).fill(0);
                    for (let i = 0; i < SIZE; i++) {
                        for (let j = 0; j < SIZE - i; j++) {
                            correlation[i] += buffer[j] * buffer[j + i];
                        }
                    }
                    
                    let d = 0;
                    while (correlation[d] > 0 && d < SIZE) {
                        d++;
                    }
                    let maxVal = -1;
                    let maxIdx = -1;
                    
                    for (let i = d; i < SIZE; i++) {
                        if (correlation[i] > maxVal) {
                            maxVal = correlation[i];
                            maxIdx = i;
                        }
                    }
                    return sampleRate / maxIdx;
                }
                
                self.onmessage = function(e) {
                    const { buffer, sampleRate } = e.data;
                    const pitch = autoCorrelate(buffer, sampleRate);
                    self.postMessage(pitch);
                };`
            ], { type: 'application/javascript' })));

            pitchDetectorWorkerRef.current.onmessage = (e) => {
                const pitch = e.data;
                if (pitch > 0) {
                    setTunerStatus(`Pitch: ${pitch.toFixed(2)} Hz`);
                } else {
                    setTunerStatus('No sound detected');
                }
            };
            
            const bufferSize = analyserRef.current.fftSize;
            const buffer = new Float32Array(bufferSize);

            const detectPitch = () => {
                analyserRef.current.getFloatTimeDomainData(buffer);
                pitchDetectorWorkerRef.current.postMessage({
                    buffer: buffer.slice(),
                    sampleRate: audioContextRef.current.sampleRate
                });
                animationFrameIdRef.current = requestAnimationFrame(detectPitch);
            };
            animationFrameIdRef.current = requestAnimationFrame(detectPitch);

        } catch (err) {
            console.error('Error accessing microphone:', err);
            setIsTunerActive(false);
            setTunerStatus('Error accessing microphone');
            if (err.name === 'NotAllowedError') {
                setMicrophoneAvailable(false);
            }
        }
    };

    const stopTuner = () => {
        setIsTunerActive(false);
        if (animationFrameIdRef.current) {
            cancelAnimationFrame(animationFrameIdRef.current);
        }
        if (sourceRef.current) {
            sourceRef.current.disconnect();
            sourceRef.current.mediaStream.getTracks().forEach(track => track.stop());
        }
        if (audioContextRef.current) {
            audioContextRef.current.close();
            audioContextRef.current = null;
        }
        if (pitchDetectorWorkerRef.current) {
            pitchDetectorWorkerRef.current.terminate();
            pitchDetectorWorkerRef.current = null;
        }
        setTunerStatus('No sound detected');
    };

    return (
        <div className="min-h-screen bg-gray-900 text-gray-100 flex flex-col items-center justify-center p-4 font-sans">
            <div className="w-full max-w-4xl bg-gray-800 rounded-2xl shadow-xl flex flex-col h-[90vh]">
                {/* Header Section */}
                <div className="p-4 bg-gray-700 rounded-t-2xl flex items-center justify-between">
                    <div className="flex items-center space-x-2">
                        <MusicIcon size={24} />
                        <h1 className="text-xl font-bold">Madison AI (Hybrid)</h1>
                    </div>
                    {/* Online/Offline Status Indicator */}
                    <span className={`px-3 py-1 rounded-full text-sm font-semibold ${isAuthReady ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}`}>
                        {isAuthReady ? 'Online Mode' : 'Connecting...'}
                    </span>
                </div>

                {/* Main Content Area */}
                <div className="flex-grow p-4 overflow-y-auto custom-scrollbar relative">
                    {/* Firestore Error Message */}
                    {firestoreError && (
                        <div className="absolute top-4 left-0 right-0 mx-auto w-full max-w-md p-3 bg-red-600 text-white rounded-lg shadow-lg z-10 text-center">
                            {firestoreError}
                        </div>
                    )}
                    {/* Microphone Error Message */}
                    {!microphoneAvailable && (
                        <div className="absolute top-16 left-0 right-0 mx-auto w-full max-w-md p-3 bg-red-600 text-white rounded-lg shadow-lg z-10 text-center">
                            Microphone not found. Please connect a microphone and grant permission to your browser.
                        </div>
                    )}

                    <div className="flex flex-col h-full space-y-4">
                        {/* Introductory Message */}
                        <div className="bg-indigo-600 text-white p-4 rounded-xl shadow-md self-start max-w-md">
                            <h2 className="font-bold text-lg">Music Studio</h2>
                            <p className="mt-2 text-sm">
                                Record your ideas, write your lyrics, or tune an instrument.
                            </p>
                        </div>
                        
                        {/* Chat messages */}
                        <div className="flex-grow overflow-y-auto space-y-4">
                            {messages.map((msg, index) => (
                                <div
                                    key={index}
                                    className={`p-4 rounded-xl shadow-md max-w-lg ${
                                        msg.role === 'user' ? 'bg-gray-700 self-end ml-auto' : 'bg-indigo-700 self-start mr-auto'
                                    }`}
                                >
                                    <div dangerouslySetInnerHTML={{ __html: renderMarkdown(msg.text) }} />
                                </div>
                            ))}
                            <div ref={messagesEndRef} />
                        </div>
                    </div>
                </div>

                {/* Footer Input Area */}
                <div className="p-4 bg-gray-700 rounded-b-2xl">
                    <div className="flex items-center justify-between space-x-4">
                        {/* Mode Toggles */}
                        <div className="flex space-x-2">
                            {/* Refine Writing Button */}
                            <button
                                className={`p-2 rounded-full transition-colors duration-200 ${
                                    activeMode === 'refine' ? 'bg-indigo-500 text-white' : 'bg-gray-600 text-gray-400'
                                }`}
                                onClick={() => setActiveMode('refine')}
                                aria-label="Refine Writing"
                            >
                                <WandIcon size={20} />
                            </button>

                            {/* Explain Code Button */}
                            <button
                                className={`p-2 rounded-full transition-colors duration-200 ${
                                    activeMode === 'explain' ? 'bg-indigo-500 text-white' : 'bg-gray-600 text-gray-400'
                                }`}
                                onClick={() => setActiveMode('explain')}
                                aria-label="Explain Code"
                            >
                                <CodeIcon size={20} />
                            </button>

                            {/* Tuner Button */}
                            <button
                                className={`p-2 rounded-full transition-colors duration-200 ${
                                    isTunerActive ? 'bg-red-500 text-white' : 'bg-gray-600 text-gray-400'
                                }`}
                                onClick={isTunerActive ? stopTuner : startTuner}
                                disabled={!microphoneAvailable}
                                aria-label="Toggle Tuner"
                            >
                                {isTunerActive ? <MicIcon size={20} /> : <AudioWaveformIcon size={20} />}
                            </button>
                        </div>

                        {/* Input Field and Send Button */}
                        <div className="flex-grow flex items-center bg-gray-600 rounded-full px-4 py-2 space-x-2">
                            <input
                                type="text"
                                className="flex-grow bg-transparent outline-none text-white placeholder-gray-400"
                                placeholder={isTunerActive ? tunerStatus : "Type a message..."}
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        activeMode === 'refine' ? handleRefineWriting() : handleExplainCode();
                                    }
                                }}
                                disabled={isAIGenerating || isTunerActive}
                            />
                            <button
                                className="p-2 bg-indigo-500 text-white rounded-full transition-colors duration-200 hover:bg-indigo-400 disabled:bg-gray-500 disabled:cursor-not-allowed"
                                onClick={() => {
                                    activeMode === 'refine' ? handleRefineWriting() : handleExplainCode();
                                }}
                                disabled={!input.trim() || isAIGenerating || isTunerActive}
                                aria-label="Send Message"
                            >
                                <SendIcon size={20} />
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default App;
